(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{338:function(t,e,n){},368:function(t,e,n){"use strict";var i=n(338);n.n(i).a},373:function(t,e,n){"use strict";n.r(e);n(366),n(367);var i={name:"graph-sample",mounted:function(){Prism.highlightAll()}},r=(n(368),n(8)),o=Object(r.a)(i,(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"graph-container"},[e("div",{staticClass:"graph-code"},[e("pre",[e("code",{staticClass:"language-java"},[this._v('public class HelloActivity {\n\n  static final String TASK_LIST = "HelloActivity";\n\n  /** Workflow interface has to have at least one method annotated with @WorkflowMethod. */\n  public interface GreetingWorkflow {\n    /** @return greeting string */\n    @WorkflowMethod(executionStartToCloseTimeoutSeconds = 10, taskList = TASK_LIST)\n    String getGreeting(String name);\n  }\n\n  /** Activity interface is just a POJI. */\n  public interface GreetingActivities {\n    @ActivityMethod(scheduleToCloseTimeoutSeconds = 2)\n    String composeGreeting(String greeting, String name);\n  }\n\n  /** GreetingWorkflow implementation that calls GreetingsActivities#composeGreeting. */\n  public static class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    /**\n     * Activity stub implements activity interface and proxies calls to it to Cadence activity\n     * invocations. Because activities are reentrant, only a single stub can be used for multiple\n     * activity invocations.\n     */\n    private final GreetingActivities activities =\n        Workflow.newActivityStub(GreetingActivities.class);\n\n    @Override\n    public String getGreeting(String name) {\n      // This is a blocking call that returns only after the activity has completed.\n      return activities.composeGreeting("Hello", name);\n    }\n  }\n\n  static class GreetingActivitiesImpl implements GreetingActivities {\n    @Override\n    public String composeGreeting(String greeting, String name) {\n      return greeting + " " + name + "!";\n    }\n  }\n\n  public static void main(String[] args) {\n    // Start a worker that hosts both workflow and activity implementations.\n    Worker.Factory factory = new Worker.Factory(DOMAIN);\n    Worker worker = factory.newWorker(TASK_LIST);\n    // Workflows are stateful. So you need a type to create instances.\n    worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n    // Activities are stateless and thread safe. So a shared instance is used.\n    worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n    // Start listening to the workflow and activity task lists.\n    factory.start();\n\n    // Start a workflow execution. Usually this is done from another program.\n    WorkflowClient workflowClient = WorkflowClient.newInstance(DOMAIN);\n    // Get a workflow stub using the same task list the worker uses.\n    GreetingWorkflow workflow = workflowClient.newWorkflowStub(GreetingWorkflow.class);\n    // Execute a workflow waiting for it to complete.\n    String greeting = workflow.getGreeting("World");\n    System.out.println(greeting);\n    System.exit(0);\n  }\n}')]),this._v("\n")])]),this._v(" "),e("div",{staticClass:"graph"},[e("iframe",{attrs:{width:"100%",height:"100%",src:"https://codemma.github.io/cadenceDecisionTree/#/tree/957bad90-9c99-4afb-8ccc-0e550a439a60",frameborder:"0",allowfullscreen:""}})])])}],!1,null,"015ef3e0",null);e.default=o.exports}}]);